## 웹을 지탱하는 기술

- HTTP
  - 기본
  - 메서드



### HTTP 기본

---

HTTP는 REST의 중요한 특징인 Uniform 인터페이스, 스테이트리스 서버, 캐시 등을 구현하고 있는 Web의 기반이 되는 프로토콜이다.



HTTP는 TCP/IP를 기반으로 하고 있고 인터넷의 네트워크 프로토콜은 계층 구조를 가지고 있다.

그 구조는 다음과 같다.

<details>
<summary>네트워크 인터페이스 → 인터넷 계층 → 전송 계층 → 응용 계층</summary>
우선 가장 아래의 네트워크 인터페이스가 있다.<br>
이는 물리적인 케이블이나 네트워크 어댑터에 해당하는 부분이다.<br>
인터넷 계층은 네트워크 인터페이스 계층 위에 있다.<br>
이 계층이 담당하는 부분은 네트워크에서 데이터를 실제로 주고받는 것이다.<br>
TCP/IP에서 IP가 여기에 해당된다.<br>
IP에서는 데이터의 기본적인 통신단위를 '패킷'이라 하며 지정한 IP 주소와 패킷 단위로 데이터를 주고받으면서 통신한다.<br>
전송 계층은 인터넷 계층 위에 있다.<br>
IP가 하지 않았던 데이터의 무결성을 보증하는 것이 전송 계층의 역활이다.<br>
TCP/IP에서 TCP가 전송 계층에 해당하며 TCP는 목적지의 상대에 대해서 커넥션을 연결한다.<br>
이 커넥션을 사용해 데이터 누락을 체크하고, 데이터의 도달을 보증한다.<br>
TCP로 접속된 커넥션에서 전송하는 데이터가 어느 애플리케이션으로 전달될지 결정하는 것이 포트번호이다.<br>
전송 계층 위에는 응용 계층이 있다. <br>
응용 계층은 구체적인 인터넷 애플리케이션, 메일, DNS 그리고 HTTP를 실현하는 계층이다.<br>
TCP로 프로그램을 만들 때는 소켓이라 불리는 라이브러리를 사용한다.<br>
소켓은 네트워크에서 데이터 교환을 추상화한 API로 접속, 송신, 수신, 절단 등의 기본적인 기능을 갖추고 있다.<br>
HTTP 서버와 브라우저는 소켓을 이용하여 구현한다.<br>
</details>



HTTP 표준화

1.0 에서는 헤더의 도입, GET 이외의 메서드 추가 

1.1 에서는 HTTP 1.0의 기능에 더해 채널 전송, Accept 헤더에 의한 콘텐트 네고시에이션, 복잡한 캐시 컨트롤, 지속적인 연결 등의 기능이 추가



#### 클라이언트와 서버

---

웹은 아키텍처 스타일로 클라이언트/서버를 채용하고 있다. 

즉 클라이언트가 정보를 제공하는 서버에 접속하여 각종 요청을 보내고 응답을 받는 구조다.

이런 프로토콜을 요청/응답형 프로토콜이라 한다.

서버에서의 처리에 시간이 많이 걸리는 경우라도 요청을 보낸 클라이언트는 응답이 돌아올 때까지 대기한다.

이는 HTTP가 동기형 프로토콜이기 때문이다.



요청과 응답을 주고 받을 때 클라이언트에서 일어나는 일

1. 요청 메시지 구축
2. 요청 메시지 송신
3. 응답이 돌아올 때까지 대기
4. 응답 메시지 수신
5. 응답 메시지 해석
6. 클라이언트의 목적을 달성하기 위해 필요한 처리

요청과 응답을 주고 받을 때 서버에서 일어나는 일

1. 요청이 올 때까지 대기
2. 요청 메시지 수신
3. 요청 메시지 해석
4. 적절한 애플리케이션 프로그램으로 처리를 위임
5. 애플리케이션 프로그램으로부터 결과 취득
6. 응답 메시지 구축
7. 응답 메시지 송신



#### HTTP 메시지

---

요청 메시지와 응답 메시지를 합해서 HTTP 메시지라고 부른다.



##### 요청 메시지

----

```
GET/testHTTP/1.1
Host : example.com
```



###### 요청라인

요청 메시지의 첫 번째 라인은 요청라인이라고 하며 메서드, 요청 URI, 프로토콜 버전으로 구성된다.



###### 헤더

요청 메시지의 둘째 줄부터는 헤더가 이어진다. 

헤더는 메시지의 메타 데이터이다.

하나의 메시지는 복수의 헤더를 가질 수 있고 각 헤더는 '이름:값'의 구성을 하고 있다.



###### 바디

위의 예시에서는 나오지 않았지만, 헤더 뒤에 바디가 이어지는 경우가 있다.

바디에는 그 메시지를 나타내는 본질적인 정보가 들어간다.

예를 들어, 리소스를 새로 작성하거나 갱실할 때는 요청의 바디부분에 리소스 표현 자체가 들어간다.



##### 응답 메시지

---

```
HTTP/1.1 200 OK
Content-Type : application/xhtml+xml; charset = utf-8

<html xmlns = "http://www.w3.org/1999/xhtml">
...
</html>
```



###### 스테이터스 라인

응답 메시지의 첫째 줄은 스테이터스 라인이라 하며, 프로토콜 버전, 스테이터스 코드, 텍스트 구문으로 구성된다.

스테이터스 코드는 요청의 결과를 프로그램으로 처리 가능한 수치 코드로 표현한다.



###### 헤더

응답 메시지의 둘째 줄부터는 요청 메시지와 마찬가지로 헤더이다



###### 바디

이 응답 메시지에는 바디도 포함되어 있다. 

헤더와 바디는 빈 줄로 구분된다.



#### HTTP의 스테이트리스성

---

HTTP는 스테이트리스한 프로토콜로 설계되어 있다.

스테이트리스란 '서버가 클라이언트의 애플리케이션 상태를 보존하지 않는다'는 제약을 말한다.

이는 처음부터 '애플리케이션 상태'가 무엇인지 알고 있어야 하기 때문에 이해가 잘 가지 않는다.



##### 애플리케이션 상태

---

우선 애플리케이션 상태란 무엇일까?

애플리케이션 상태는 다른 이름으로 '세션 상태' 라고도 한다.

시스템에 로그인하고부터 로그아웃할 때까지 일련의 조작을 모아 "세션"이라 부르는데, 이 일련의 조작 중의 상태는 애플리케이션 상태를 말하는 것으로, 애플리케이션 상태와 세션 상태는 거의 동일한 의미가 된다.



##### 스테이트풀의 결점

---

서버가 클라이언트의 애플리케이션 상태를 기억하는 것은 클라이언트의 수가 증가함에 따라 어려워지게 된다.



##### 스테이트리스의 이점

---

이러한 문제를 해결하는 것이 스테이트리스한 아키텍처이다.

스테이트리스는 클라이언트가 요청 메시지에 필요한 정보를 모두 포함시킨다.

요청을 처리하는 데 필요한 정보가 모두 포함되어 있는 메시지를 가리켜 '자기 기술적 메시지' 라고 한다.

스테이트리스한 아키텍처에서는 서버가 클라이언트의 애플리케이션 상태를 기억하는 대신에 클라이언트가 자신의 애플리케이션 상태를 기억하고 모든 요청을 기술적 메시지로 송신한다.



##### 스테이트리스의 결점

---

- 퍼포먼스의 저하
  서버를 스테이트리스로 만들기 위해서는 클라이언트는 매번 필요한 정보를 모두 송신해야 한다.
  그래서 송신할 데이터의 양이 많아지고 인증등의 서버에 부하가 걸리는 처리를 반복한다면 퍼포먼스의 저하가 일어난다.
- 통신 에러에 대한 대처
  통신 에러가 일어난다면 클라이언트는 정보를 모두 다시 송신하여야 한다. 
  이전의 정보는 서버에 남아있지 않다.



### HTTP 메서드

---



| 메서드  | 의미                                                   |
| ------- | ------------------------------------------------------ |
| GET     | 리소스 취득                                            |
| POST    | 서브 리소스의 작성, 리소스 데이터의 추가, 그 밖의 처리 |
| PUT     | 리소스 갱신, 리소스 작성                               |
| DELETE  | 리소스 삭제                                            |
| HEAD    | 리소스의 헤어(메타 데이터) 취득                        |
| OPTIONS | 리소스가 서포트하는 메서드의 취득                      |
| TRACE   | 자기 앞으로 요청 메시지 반환(루프 백) 시험             |
| CONNECT | 프록시 동작의 터널 접속으로 변경                       |



##### CRUD

---

HTTP 메서드 중 GET, POST, PUT, DELETE는 이들 4갱의 메서드로 CRUD라는 성질을 충족시키고 있으므로 대표적인 메서드라고 할 수 있다.

CRUD는 데이터 조작의  기본이 되는 4가지 처리를 말한다.



###### GET

GET은 지정한 URI의 정보를 가져온다.

```
요청
GET /listHTTP /1.1
Host : example.com
```

```
응답
HTTP /1.1 200 OK
Content-Type : application/json

[
	{"uri" : "http://example.com/list/ietm1"},
    {"uri" : "http://example.com/list/ietm2"},
    {"uri" : "http://example.com/list/ietm3"},
]
```



###### POST 

POST는 3가지 역할이 있다.

1. 서버 리소스의 작성
   POST의 대표적인 기능은 어떤 리소스에 대한 서브 리소스의 작성이다.

   ```
   요청
   POST /listHTTP /1.1
   Host : example.com
   Content-Type : text/plain; charset=utf-8
   
   안녕하세요
   ```

   ```
   응답
   HTTP /1.1 201 Created
   Content-Type : text/plain; charset=utf-8
   Location : http://example.com/list/ietm5
   
   안녕하세요
   ```

   POST의 바디에는 새로 작성할 리소스의 내용이 들어가 있다.
   응답에서 반환된 201 Created라는 스테이터스 코드는 새로운 리소스를 생성했다는 것을 보여준다.
   Location 헤더에 새롭게 생성한 리소스의 URI가 들어 있다. 
   위의 예제에서는 /list 아래에 /list/item5라는 리소스를 새로 생성한 것이다.

   

2. 리소스에 대이터 추가
   서브 리소스의 생성만큼 일반적이지 않지만 POST의 대표적인 기능의 두 번째는 기존의 리소스에 데이터를 추가하는 것이다.
   예를 들어, 로그 리소스를 보자. 
   우선 리소스를 GET 한 결과이다.

   ```
   요청
   GET /logHTTP /1.1
   Host : example.com
   ```

   ```
   응답
   HTTP /1.1 200 OK
   Content-Type : text/csv; charset=utf-8
   
   2010-10-10T10:10:00Z, GET /list, 200
   2010-10-10T10:10:00Z, POST /list, 201
   2010-10-10T10:10:00Z, GET /list, 200
   ```

   이 리소스에 새로운 로그를 추가하기 위해 POST를 사용한다.

   ```
   요청 
   POST /logHTTP /1.1
   Host : example.com
   
   2010-10-10T10:10:00Z, GET /log, 200
   ```

   ```
   응답
   HTTP /1.1 200 OK
   ```

   응답에서 201 Created가 아니라 200 OK가 반환되었다.
   요청이 신규 리소스를 작성한 것이 아니라, 데이터의 추가를 의미했기 때문이다.

3. 다른 메서드로는 대응할 수 없는 처리
   POST는 GET에서는 URI에 포함시켰던 키워드를 요청 메시지의 바디에 넣을 수 있다.
   이렇게 함으로써 아무리 긴 키워드라도 사용할 수 있다.

   ```
   POST /search HTTP /1.1
   Content-Type : application/x-www-form-urlencoded
   
   q=very+long+keyword+foo+bar+.............
   ```



###### PUT

PUT은 두 가지의 기능을 가지고 있다. 

리소스의 갱신과 리소스의 작성이다.



1. 리소스의 갱신

   ```
   요청 
   PUT /list/item5 HTTP /1.1
   Host : example.com
   Content-Type : text/plain; charset=utf-8
   
   좋은 밤이네요!
   ```

   ```
   응답
   HTTP /1.1 200 OK
   Content-Type : text/plain; charset=utf-8
   
   좋은 밤이네요!
   ```

   PUT으로 응답에 리소스를 갱신한 결과 이전의 '안녕하세요!'에서 '좋은 밤이네요!'라고 리소스가 갱신되었다.

2. 리소스의 작성

   ```
   요청
   PUT /newitem HTTP /1.1
   Host : example.com
   Content-Type : text/plain; charset=utf-8
   
   새로운 리소스 /newitem의 내용
   ```

   ```
   응답
   HTTP /1.1 201 Created
   Content-Type : text/plain; charset=utf-8
   
   새로운 리소스 /newitem의 내용
   ```

   위의 PUT은 존재하지 않는 URI에 대한 요청이기 때문에 서버는 리소스를 새로 작성한다고 해석하고 요청이 성공한 경우에는 201 Created를 반환한다.
   POST의 경우는 새롭게 작성한 URI가 Location 헤더로 반환되었지만, PUT의 경우는 클라이언트가 이미 리소스의 URI를 알고 있기 때문에 Location 헤더를 반환할 필요가 없다.



###### POST vs PUT

POST로 리소스를 작성할 경우, 클라이언트는 리소스의 URI를 지정할 수 없다.

URI의 결정권은 서버에 있다.

PUT은 리소스를 작성할 경우, 리소스의 URI는 클라이언트가 결정한다.

일반적으로, 클라이언트가 리소스의 URI를 결정할 수 있다는 것은 클라이언트를 만드는 프로그래머가 서버의 내부구현을 숙지하고 있어야 한다.

그 때문에 PUT이 아무래도 서버와의 결합이 밀접하다.

특별한 이유가 없는 한, 리소스의 작성은 POST로 수행하여 URI를 서버 측에서 결정하는 설계가 바람직하다.



###### DELETE

DELETE는 이름 그대로 리소스를 삭제하는 메서드이다.

```
요청
DELETE /list/item2 HTTP /1.1
Host : example.com
```

```
응답
HTTP /1.1 200 OK
```



###### HEAD

HEAD는 GET과 유사한 메서드이다.
GET은 리소스를 취득하는 메서드지만, HEAD는 리소스의 헤더만을 취득하는 메서드이다.

```
요청
HEAD /list/itme1 HTTP /1.1
Host : example.com
```

```
응답
HTTP /1.1 200 OK
Content-Type : text/plain; charset=utf-8
```

HEAD에 대한 응답에는 바디가 포함되지 않는다.



###### OPTIONS

OPTIONS는 그 리소스가 지원하고 있는 메서드의 목록을 반환한다.

```
요청
OPTIONS /list HTTP /1.1
Host : example.com
```

```
응답
HTTP /1.1 200 OK
Allpw : GET, HEAD, POST
```

응답에 포함되는 Allow 헤더는 그 리소스가 허용하는 메서드의 목록이다.



##### POST를 PUT/DELETE 대신 사용하는 방법

---

HTML의 폼에서는 지정할 수 있는 메서드가 GET과 POST 뿐이다.

```html
<form action"GET" target="/list">
...
</form>
```

```html
<form action"POST" target="/list">
...
</form>
```

이러 제한은 Ajax의 발전과 함께 계속 해소되고 있는 중이다.

Ajax에서 이용하는 XMLHttpRequest라는 모듈을 이용하면, 임의의 메서드를 발행할 수 있다.



그래도 우선 서버에 PUT이나 DELETE를 전달하는 방법을 알아보자.

1. _method 파라미터
   폼의 숨겨진 파라미터에 _method라는 파라미터를 준비하고 그 곳에 원래 보내고 싶었던 메서드의 이름을 넣는다. _method 파라미터는 Ruby on Rails가 채용하고 있다.

   ```html
   폼
   <form target="/list/itme1" action ="POST">
       <input type="hidden" id="method" value="PUT">
       ...
   </form>
   ```

   위와 같은 폼을 송신하면 다음과 같은 요청이 보내진다.

   ```
   POST /list/item1 HTTP /1.1
   Host : example.com
   Content-Type : application/x-www-form-urlencoded
   
   _method=PUT&...
   ```

   바디에는 폼에서 입력된 항복을 URI의 쿼리 파라미터와 같은 스펙으로 인코딩한 텍스트가 들어 있다.

   Content-Type 헤더의 값 application/x-www-form-urlencoded는 이 포맷을 나타내는 미디어 타입이다.

2. X-HTTP-Method-Override
   _method 파라미터는 폼을 이용해 요청을 보낼 경우에는 효과적인 방법이지만, POST의 내용이 XML 등 application/x-www-form-urlencoded 이외의 경우에는 이용할 수 없다.
   이런 경우에 이용할 수 있는 것이 X-HTTP-Method-Override 헤더이다. 
   이는 Google의 GData가 채용하고 있는 방식이다.

   ```
   POST /list/item1 HTTP /1.1
   Host : example.com
   Content-Type : application/xml; charset=utf-8
   X-HTTP-Method-Override : PUT
   
   <body> ... </body>
   ```

   위와 같은 요청은 X-HTTP-Method-Override 헤더를 보고 PUT으로 취급한다.



##### 조건부 요청

---

HTTP 메서드와 갱신일자 등으로 헤더를 구성하면 메서드의 실행 여부를 리소스의 갱신일자 조건으로 서버가 선택할 수 있다.

이러한 요청을 '조건부 요청'이라 한다.



##### 멱등성과 안전성

---

멱등성이란 '어떤 조작을 몇 번을 반복해도 결과가 동일한 것'을 의미하는 수학용어이다.

안전이란 '조작 대상의 리소스의 상태를 변화시키지 않는 것'을 의미한다.

리소스의 상태에 변화를 부여하는 것을 부작용이라 하므로, 안전은 '조작대상인 리소스에 부작용이 없는 것'이라고도 한다.

| 메서드      | 성질                        |
| ----------- | --------------------------- |
| GET, HEAD   | 멱등이고 안전하다.          |
| PUT, DELETE | 멱등이지만 안전하지 않다.   |
| POST        | 멱등이지도 안전하지도 않다. |

